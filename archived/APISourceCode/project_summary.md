# SMS-Receiver-API.txt

```txt
<Project Sdk="Microsoft.NET.Sdk.Web"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <RootNamespace>SMS_Receiver_API</RootNamespace> </PropertyGroup> <ItemGroup> <Compile Include="Data\ConTXTContext.fs" /> <Compile Include="Controllers\SmsController.fs" /> <Compile Include="Program.fs" /> <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" /> <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" /> <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" /> </ItemGroup> </Project>
```

# appsettings.json

```json
// appsettings.json { "ConnectionStrings": { "DefaultConnection": "Server=SQL1.reliantrack.local;Database=ConTXT;User Id=sa;Password=Gr3@tSc0tch;TrustServerCertificate=True" }, "Logging": { "LogLevel": { "Default": "Information", "Microsoft.AspNetCore": "Warning" } }, "AllowedHosts": "*" }
```

# Program.fs

```fs
// Program.fs open System open Microsoft.AspNetCore.Builder open Microsoft.Extensions.DependencyInjection open Microsoft.Extensions.Hosting open Microsoft.EntityFrameworkCore open ConTXT.Data open Microsoft.Extensions.Configuration open Microsoft.Extensions.Logging open Microsoft.OpenApi.Models open Microsoft.AspNetCore.Mvc.Infrastructure [<EntryPoint>] let main args = let builder = WebApplication.CreateBuilder(args) // Add services to the container builder.Services.AddControllers() |> ignore builder.Services.AddDbContext<ConTXTContext>(fun options -> options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")) |> ignore ) |> ignore // Add Swagger only in Development environment if builder.Environment.IsDevelopment() then builder.Services.AddEndpointsApiExplorer() |> ignore builder.Services.AddSwaggerGen(fun c -> c.SwaggerDoc("v1", OpenApiInfo(Title = "SMS Receiver API", Version = "v1")) ) |> ignore // Build the application let app = builder.Build() app.Logger.LogInformation("Application starting up") // Configure the HTTP request pipeline if app.Environment.IsDevelopment() then app.UseSwagger() |> ignore app.UseSwaggerUI(fun c -> c.SwaggerEndpoint("/swagger/v1/swagger.json", "SMS Receiver API V1") ) |> ignore app.UseHttpsRedirection() |> ignore app.UseAuthorization() |> ignore app.MapControllers() |> ignore app.Logger.LogInformation("Controllers mapped") // Log route information (you can keep or remove this based on your needs) let actionDescriptorCollectionProvider = app.Services.GetService<IActionDescriptorCollectionProvider>() if actionDescriptorCollectionProvider <> null then let routes = actionDescriptorCollectionProvider.ActionDescriptors.Items for route in routes do let controllerName = route.RouteValues.["controller"] let actionName = route.RouteValues.["action"] let httpMethods = String.Join(", ", route.ActionConstraints |> Seq.choose (function :? Microsoft.AspNetCore.Mvc.ActionConstraints.HttpMethodActionConstraint as c -> Some (String.Join(", ", c.HttpMethods)) | _ -> None)) app.Logger.LogInformation(sprintf "Controller: %s, Action: %s, HTTP Methods: %s" controllerName actionName httpMethods) app.Run() 0 // Exit code
```

# ConTXTContext.fs

```fs
// ConTXTContext.fs namespace ConTXT.Data open System open System.ComponentModel.DataAnnotations open Microsoft.EntityFrameworkCore type Contact() = member val ContactID : int = 0 with get, set member val UserID : int = 0 with get, set member val ContactName : string = "" with get, set member val PhoneNumber : string = "" with get, set member val EmailAddress : string = "" with get, set type Sms() = member val SMSID : int = 0 with get, set member val ContactID : int = 0 with get, set member val Message : string = "" with get, set member val Status : string = "" with get, set member val DateTime : DateTime = DateTime.MinValue with get, set member val TextID : string = "" with get, set member val Number : string = "" with get, set member val Direction : string = "" with get, set member val Processed : char = 'N' with get, set member val EmailID : int = 0 with get, set type ConTXTContext(options: DbContextOptions<ConTXTContext>) = inherit DbContext(options) [<DefaultValue>] val mutable sms : DbSet<Sms> member this.SMS with get() = this.sms and set v = this.sms <- v [<DefaultValue>] val mutable contacts : DbSet<Contact> member this.Contacts with get() = this.contacts and set v = this.contacts <- v override this.OnModelCreating(modelBuilder: ModelBuilder) = modelBuilder.Entity<Sms>().ToTable("SMS") |> ignore
```

# launchSettings.json

```json
// launchSettings.json { "$schema": "http://json.schemastore.org/launchsettings.json", "iisSettings": { "windowsAuthentication": false, "anonymousAuthentication": true, "iisExpress": { "applicationUrl": "http://localhost:44683", "sslPort": 44371 } }, "profiles": { "http": { "commandName": "Project", "dotnetRunMessages": true, "launchBrowser": true, "launchUrl": "swagger", "applicationUrl": "http://localhost:5002", "environmentVariables": { "ASPNETCORE_ENVIRONMENT": "Development" } }, "https": { "commandName": "Project", "dotnetRunMessages": true, "launchBrowser": true, "launchUrl": "swagger", "applicationUrl": "https://localhost:7205;http://localhost:5002", "environmentVariables": { "ASPNETCORE_ENVIRONMENT": "Development" } }, "IIS Express": { "commandName": "IISExpress", "launchBrowser": true, "launchUrl": "swagger", "environmentVariables": { "ASPNETCORE_ENVIRONMENT": "Development" } } } }
```

# SmsController.fs

```fs
// SmsController.fs namespace ConTXT.Controllers open Microsoft.AspNetCore.Mvc open System open ConTXT.Data open Microsoft.EntityFrameworkCore open System.Threading.Tasks open System.Linq open Microsoft.FSharp.Core [<ApiController>] [<Route("api/[controller]")>] type SmsController(context: ConTXTContext) = inherit ControllerBase() // Helper function to normalize phone numbers let normalizePhoneNumber (phoneNumber: string) : string = new string(phoneNumber.ToCharArray() |> Array.filter Char.IsDigit) // Helper function to create a LIKE pattern let createLikePattern (phoneNumber: string) : string = let digits = normalizePhoneNumber phoneNumber "%" + String.Join("%", digits.ToCharArray()) + "%" [<HttpPost>] member this.ReceiveSms([<FromBody>] payload: SmsPayload) : Task<IActionResult> = task { let normalizedIncomingNumber = normalizePhoneNumber payload.FromNumber let likePattern = createLikePattern payload.FromNumber let! potentialMatches = context.Contacts .Where(fun c -> EF.Functions.Like(c.PhoneNumber, likePattern)) .ToListAsync() let contact = potentialMatches |> Seq.tryFind (fun c -> normalizePhoneNumber c.PhoneNumber = normalizedIncomingNumber) match contact with | None -> return this.BadRequest("No matching contact found for the given phone number") :> IActionResult | Some contact -> // Check for matching TextID in the database, get the most recent let! matchingSms = context.SMS .Where(fun s -> s.TextID = payload.TextId) .OrderByDescending(fun s -> s.DateTime) // Sort by DateTime in descending order .FirstOrDefaultAsync() let emailId = if isNull (box matchingSms) then 0 else matchingSms.EmailID let sms = Sms() sms.ContactID <- contact.ContactID sms.Message <- payload.Text sms.Status <- "Delivered" sms.DateTime <- DateTime.Now sms.TextID <- payload.TextId sms.Number <- payload.FromNumber sms.Direction <- "Inbound" sms.Processed <- 'N' sms.EmailID <- emailId // Use the EmailID from the most recent matching SMS, or 0 if not found context.SMS.Add(sms) |> ignore try do! context.SaveChangesAsync() |> Async.AwaitTask |> Async.Ignore return this.Ok(sprintf "SMS received and logged successfully for contact: %s. EmailID: %d" contact.ContactName emailId) :> IActionResult with | ex -> // Log the exception return this.StatusCode(500, "An error occurred while processing the SMS") :> IActionResult } [<HttpGet("test")>] member this.Test() : IActionResult = this.Ok("API is working") :> IActionResult and SmsPayload = { TextId: string FromNumber: string Text: string }
```

